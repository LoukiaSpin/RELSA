---
title: "RELSA Vignette"
author: "Steven R. Talbot"
date: "2019-04-20"
output: 
    rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{RELSA_Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
bibliography: relsa_lit.bib
---

# Relative Severity Assessment (RELSA) Score

### What is RELSA?
The RELSA package contains a set of functions for **assessing relative severity in laboratory animals**. In animal-based research the problem of severity classification is crucial. As animals cannot communicate their state of well-being, scientists need reliable tools for monitoring severity as closely as possible. It has been shown that a diversity of behavioural tests (and others) may serve this purpose. However, the main issue with these approaches is that they are rather specific and difficult to transfer. A comprehensive and easy to use toolbox for the assessment and comparison of different variables and animal models is missing. RELSA offers a first glimpse into this matter by combining any set of experimental outcome variables into a single composite score.

### What is RELSA not?
Foremost, RELSA is not (yet) a predictor of death in laboratory animals!

At its current state of development it is meant as a guideline or tool for researchers working with laboratory animals to use in their daily work and to monitor relative severity. It is not (yet) meant as a unified solution for a) the definition b) grading and c) objective classification of severity. Nevertheless, it may help in finding more objective thresholds with more data.

## Dependencies
In order to run the RELSA package the following package is needed and can be loaded from CRAN: dichromat [@Yes2015].

## Installation
The following commands can be used in R to download and install the developer version of the RELSA package. The second command is required to build the associated vignettes (if needed).

```
devtools::install_github("mytalbot/relsa", build_vignettes = TRUE)
```

# RELSA background
**RELSA in one sentence:** The RELSA score is a generalized quantification of multi-variable differences. 

Variable changes are monitored with regard to their baseline or physiological states and the changes are stored. With data from a well-defined reference set severity context can be extrapolated. Trivially, the extrema (min/max) of each variable in the reference set serve as ranges for the given severity context. The only caveat here is: researchers must provide some sort of estimation about the quality of severity in the reference experiment.

It does not matter, however, if this severity is classified as "low"", "medium"" or "severe". The relative context will shift the scale to lower or higher values, depending on the maximum escalations in the reference set. The final RELSA score is calculated from weight factors, regularized by the extrema from the reference set. At last, special focus is laid on the fact that larger weights are more important than smaller changes in terms of severity, which is included in the final score.

Missing data are set to NA and not to zero or imputed otherwise. If set to zero, this would allow empty terms in the calculation of, e.g. the mean. The result would be a skewed reflection of what actually happens in the data towards unimportant values. Introducing NAs allows a more fair calculation of the score in terms of potential severity, as these values will not be included in the calculations. This lays more focus on actually present variables and allows the calculation of RELSA scores for data sets with lots of missing data.

Thus, the RELSA score is an abstraction of what actually happens in the data at specific time points. This form of data reduction has the disadvantage that it loses the ability to observe differences in variable distributions. But that is a price every composite score has to pay at some point.

Besides providing context, the reference set has another purpose: it regularizes the possible ranges of variables. This can prove essential, as variables behave differently when animals are negatively affected. For example, a loss of 17 \%\ in body weight is generally recognized as being a rather substantial threat to animal health. In the same time burrowing behavior may drop to zero \%\. Here, a difference of 17 \%\ is equivalent to 100 \%\ at the same time of observation. However, in other animal models this may not be the case. By comparing the actual ranges to the reference set, this kind of bias is regularized resulting in the weight factors.

A conclusion from this would be that certain parameters are lagging, others are leading, or, that interactions are model-dependent. The main issues here are not the parameters themselves but rather the experimental design and sampling frequency. Body weight is measured, e.g. once per day (i.e. in the morning) and burrowing behavior after a certain time period (after 2 hours or after one night period). The sampling rates in these cases are a) not equal and b) not frequent enough to catch minute changes. Transient ranges of some variables thus appear as “all-or-nothing” parameters. They change much faster than the sampling rates so that the exact development over time cannot be seen.

Although, the sampling rate cannot be corrected with RELSA, the skewness in distribution can be adjusted to a certain degree by including extreme values of a training or reference model with known severity into the calculation. These values are called baseline (severity) values for the given animal model in the training set.

The RELSA score itself is pretty easy to interpret. If it shows, e.g. 0.85 it translates that the variables in a test animal have reached 85 \%\ of the (generalized) maximum escalation level of the reference set. If values are larger than 1 (100 \%\), this is a good indication for higher severity than within the reference set. This is particularly interesting for data sets with different numbers of variables: some might perform better than others.


### Data design
For the current version of RELSA, the tabular data must follow a specific format. It can be loaded as \*.txt file in the tab delimited format using the `relsa_load` function. Variable names should be simple but recognizable such as, e.g. bw (body weight), body weight change (bwc), bur2h (burrowing 2 h), burON (burrowing over night), mgs (mouse grimace scale) etc.

The table should have an index colum (the first one) without a header. Animal id should be a short but unique identifier. The treatment column contains experimental information, e.g. about the nature of an experiment (Transmitter/Sham etc). The condition column includes additional information such as anesthesia, death or any other "condition" you might want to include. At the moment, only two columns can be used to specifiy conditions for filtering. Both can be used as specificators in the `relsa_load` function to load subsets of the data.

The day column contains the time information of the data in days. **This column should be of equal length for each animal** in the table even if there are no data. Just leave the fields empty. The RELSA convention for baseline value is -1. However, you can design this column differently (e.g. hours instead of days), as long as it is continously increasing. 

**IMPORTANT:** The variables in the baseline/training data must match the names in the test data which are very likeley to come from a different table.


|     |id      | treatment  | condition  | day  | variable 1 | variable n |
|:----|:-------|:-----------|:-----------|:-----|:-----------|:-----------|
| 1   |animal1 |Transmitter |Carprofen   |-1    |19.2        |454         |
| 2   |animal1 |Transmitter |Carprofen   |0     |17.8        |567         |
| 3   |animal1 |Transmitter |Carprofen   |1     |18.3        |503         |
|...  |...     |...         |...         |...   |...         |...         |

## RELSA functions

### relsa_load
```
# This function will load RELSA raw data as a data.frame.
relsa_load(file, treatment=NULL, condition=NULL)
```
The `relsa_load` function is used to import both, training and testdata. It uses the `file` argument with a complete string to the sample file (including the *testfile.txt*). The `treatment/condition` fields can used to subsample the loaded files (e.g. if the data contains both, transmitter and sham data. With `treatment="transmitter"`, only data from the "transmitter" experiment will be loaded (the spelling is case sensitive!).

### relsa_norm
```
# This function will normalize specified variables to the range [0;100].
relsa_norm(set, normthese=NULL, ontime=1)
```
`set` contains the loaded data frame obtained by `relsa_load`. The specified variables in `normthese` will be normalized to a range of [0;100]. **Important note: variables that are not specified are not normalized!** This function can also be used for the normalization of other data sets. Some variables like body weigh change (bwc) that are sometimes pre-calculated in the data tables do not need normalization and must therefore not be specified in the function. The field `ontime` specifies the timepoint in the data set to which the data in each colum should be normalized. Please note that this is not a string for the actual name of the time unit but the absolute position (rowname) in the data.frame (if, e.g. baseline values (day = -1) are at position 1 and this is the very first entry in the table, ontime=1).

### relsa_levels
```
# This function will calculate k+1 levels from kmeans analysis of the reference data for severity classification.
relsa_levels(refset, mypath, filename, drops=NULL, turns=NULL, relsaNA=NA, k=4,
                         showScree="no", customCol=NULL, seed=123, myYlim=c(0,1.4), saveTiff="yes")
```
`refset` is the normalized reference data frame. With the arguments `mypath` and `filename` the path and name of the final *.tiff file can be specified. `k`, `turns` determines the number of clusters in the data. The exact number must be found heuristically by using the internalized Scree plot. If `showScree` is set to "yes", the Scree plot is shown. `customCol` can be used to specify custom colors for the clusters. The color vector should be as long as the number of clusters. `seed` controls the random seeding and can be turned off with NULL. With `myYlim` the range of the y-axis can be controlled and `saveTiff` controls whether the final \*.tiff file shall be plotted.

### relsa_baselines
```
# This function will establish baseline values for RELSA calculation.
relsa_baselines(dataset=NULL, bslday=-1, variables=NULL, turnvars=NULL)

```
The `relsa_baselines` function is used to build baseline values from the provided reference data. It may be necessary to load and normalize the data with the two previously mentioned functions. `dataset` should contain only normalized values (range [0;100]). `bslday` points to the actual value of the time column that is to be used as baseline value (the default value is day = -1). `variables` contains a string with the actual variables for which RELSA scores shall be calculated. The testvariables in the later testset should be included here as well. Otherwise, they will not be calculated or the function will produce an error. 
The field `turnvars` is important for variables that show increasing values under duress as opposed to variables showing a decrease in values such as body weight. These variables can be specified as such: `turnvars=c("hr","score")` etc.
The output of the function is twofold: a) a matrix for each variable in the model with 100 \%\ as maximum normalized value and b) a vector with maximum/minimum reached variable values (not normalized!) in the training model.

### relsa
```
# This is the actual RELSA function.
relsa (set, bsl, a=1, drop=NULL, turnvars=NULL, relsaNA=0 )
```
`relsa` accepts normalized (testdata) from the `relsa_norm` function for analysis. However, it is possible to assess the training model as well. `bsl` is the object obtained from the `relsa_baselines` function for model referencing. `a` is the number of unique animals/animal in the set. `drop` can be used to exclude variables that are contained in the training model but shall be excluded from further analysis (e.g. drop=c("bw","score")). `turnvars` is again used to indicate variables with switched orientation. Sometimes calculations produce NaN. `relsaNA` determines how to substitute these values (default is 0).

### relsa_plot
```
# This function can be used to plot the RELSA score.
relsa_plot (set=NULL, RELSA, levels=NULL, animal=1, plotvar=NULL, plotRELSA=TRUE, myylim=c(70,110), myYlim=c(0,2), mypch=1)
```
`set` contains the loaded data frame obtained by `relsa_load` and `RELSA` the output from the `relsa` function. The `levels` argument accepts the level output from the `relsa_levels` function. The specific animal to be plotted is defined with the unique animal number in `animal`. Each variable can be plotted individually by controlling the variable name in the `plotvar` field (e.g. plotvar="bwc"). With the `plotRELSA` argument the RELSA score is plotted in addition to the variable. `myylim` controls the range of the first Y-axis on the left side of the plot and `myYlim` for the RELSA score on the left side if plotvar is not NULL. The pch argument controls the dot type (default is 1).


## Working example
Uses the internal `postop` dataset for analysis.

```
library(RELSA)

# Build model -------------------------------------------------------------
raw          <- postop
vars         <- c("bwc", "bur2h", "burON", "hr", "hrv", "temp", "act", "mgs")
turnvars     <- c("hr", "mgs", "temp" )
pre          <- relsa_norm(cbind(raw[,1:4], raw[,vars]), 
                           normthese = c("bur2h", "burON", "hr", "hrv", "temp", "act", "mgs"), ontime = 1)
bsl          <- relsa_baselines(dataset = pre, bslday = -1, variables = vars, turnvars = turnvars)
levels       <- relsa_levels(pre, bsl = bsl, drops = c("bw", "score"), turns = c("hr", "mgs", "temp"),
                             k = 4, customCol = c("red", "green", "blue", "magenta"))

# Test model --------------------------------------------------------------
animal       <- 1
RELSA        <- relsa(set = pre, bsl, a = animal, 
                      drop=c("bw", "score", "mgs30", "mgs180"), turnvars = turnvars)
head(RELSA$relsa$rms)
```

### References
 
